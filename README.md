### Соломахин Владислав
### Урок 68

Различия текстовых и двоичных файлов: Текстовые файлы содержат данные в виде символов, которые могут быть прочитаны и интерпретированы человеком (например, ASCII или UTF-8). Двоичные файлы, в свою очередь, содержат данные в формате, который не предназначен для непосредственного чтения человеком (например, изображения, аудио, исполняемые файлы). Можно сказать, что текстовый файл — это частный случай двоичного файла, так как текстовые файлы также представляют собой последовательность байтов, но с определенной интерпретацией.

Принцип сэндвича: Этот принцип подразумевает, что при работе с файлами данные могут быть записаны или прочитаны в определенном порядке, где "начинка" (данные) находится между "хлебом" (метаинформация, заголовки и т. д.). Например, при записи данных в файл сначала может быть записан заголовок, затем сами данные, а затем завершающая информация.

Блокировка открытых файлов: Когда файл открыт одной программой, он блокируется для других программ, чтобы избежать конфликтов при одновременном доступе к данным. Это предотвращает возможные ошибки, такие как запись данных в файл, который уже открыт для чтения другой программой.

Рекомендация закрывать файлы вручную: Закрытие файлов вручную позволяет гарантировать, что все данные были правильно записаны и освобождаются ресурсы, связанные с файлом. В ситуациях, когда программа неожиданно завершается (например, из-за ошибки), не закрытые файлы могут привести к потере данных или повреждению файловой системы.

Файловая переменная: Файловая переменная — это переменная, которая хранит информацию о состоянии открытого файла (например, указатель на текущую позицию в файле, режим доступа и т. д.). Использование файловой переменной вместо имени файла позволяет программе управлять несколькими открытыми файлами одновременно и отслеживать их состояние.

Использование одной файловой переменной для нескольких файлов: Одна и та же файловая переменная может быть использована для работы с несколькими файлами, если файл был закрыт и затем открыт снова с использованием той же переменной. Однако, если переменная все еще ссылается на открытый файл, то ее нельзя использовать для работы с другим файлом.

Последовательный доступ к данным: Последовательный доступ к данным подразумевает, что данные читаются или записываются в файле последовательно, от начала к концу, без возможности произвольного доступа к произвольным частям файла.

Чтение данных из файла с его начала: Чтобы начать чтение данных из файла с его начала, необходимо установить указатель на начало файла. В большинстве языков программирования для этого используется функция, например, seek(0) или аналогичная.

Определение конца данных в файле: Конец данных в файле можно определить, проверяя, возвращает ли функция чтения (например, read()) значение, указывающее на конец файла (EOF). Также может использоваться проверка на ошибку или специальный символ, указывающий на конец данных.

Максимальное количество данных в файле: Знать максимальное количество данных в файле важно в ситуациях, когда необходимо выделить фиксированное количество памяти для хранения данных. В других случаях, например, при чтении текстовых файлов построчно, это не требуется, так как данные могут быть обработаны по мере их поступления.

Открытие нескольких файлов одновременно: Открытие нескольких файлов одновременно может быть необходимо в ситуациях, когда программа должна сравнивать данные из разных файлов, объединять их, выполнять операции чтения и записи в разные файлы одновременно или обрабатывать данные из нескольких источников.

Среднее арифметическое чисел в файле def calculate_average(input_file, output_file): try: with open(input_file, 'r') as f: numbers = [float(line.strip()) for line in f if line.strip()]

average = sum(numbers) / len(numbers) if numbers else 0

with open(output_file, 'w') as f: f.write(f'Среднее арифметическое: {average}\n') except Exception as e: print(f'Ошибка: {e}')

calculate_average('input.txt', 'average_output.txt') 2. Минимальное и максимальное четных положительных чисел def min_max_even(input_file, output_file): try: with open(input_file, 'r') as f: even_numbers = [int(line.strip()) for line in f if line.strip() and int(line.strip()) > 0 and int(line.strip()) % 2 == 0]

if even_numbers:
    min_even = min(even_numbers)
    max_even = max(even_numbers)
    result = f'Минимальное: {min_even}, Максимальное: {max_even}\n'
else:
    result = 'Четные положительные числа не найдены.\n'

with open(output_file, 'w') as f:
    f.write(result)
except Exception as e: print(f'Ошибка: {e}') min_max_even('input.txt', 'min_max_output.txt') 3. Длина цепочки целых чисел def count_integers(input_file, output_file): try: with open(input_file, 'r') as f: numbers = [line.strip() for line in f if line.strip()]

count = len(numbers)

with open(output_file, 'w') as f:
    f.write(f'Количество целых чисел: {count}\n')
except Exception as e: print(f'Ошибка: {e}') count_integers('input.txt', 'count_output.txt') 4. Сортировка по последней цифре def sort_by_last_digit(input_file, output_file): try: with open(input_file, 'r') as f: numbers = [int(line.strip()) for line in f if line.strip()]

sorted_numbers = sorted(numbers, key=lambda x: x % 10)

with open(output_file, 'w') as f:
    for number in sorted_numbers:
        f.write(f'{number}\n')
except Exception as e: print(f'Ошибка: {e}') sort_by_last_digit('input.txt', 'sorted_by_last_digit.txt') 5. Сортировка по сумме цифр def sum_of_digits(n): return sum(int(digit) for digit in str(abs(n)))

def sort_by_digit_sum(input_file, output_file): try: with open(input_file, 'r') as f: numbers = [int(line.strip()) for line in f if line.strip()]

sorted_numbers = sorted(numbers, key=sum_of_digits)

with open(output_file, 'w') as f:
    for number in sorted_numbers:
        f.write(f'{number}\n')
except Exception as e: print(f'Ошибка: {e}') sort_by_digit_sum('input.txt', 'sorted_by_digit_sum.txt') 6. Объединение и сортировка двух массивов def merge_sorted_files(file1, file2, output_file): try: with open(file1, 'r') as f1, open(file2, 'r') as f2: numbers1 = [int(line.strip()) for line in f1 if line.strip()] numbers2 = [int(line.strip()) for line in f2 if line.strip()]

merged_numbers = sorted(numbers1 + numbers2)

with open(output_file, 'w') as f:
    for number in merged_numbers:
        f.write(f'{number}\n')
except Exception as e: print(f'Ошибка: {e}') merge_sorted_files('file1.txt', 'file2.txt', 'merged_output.txt') 7. Обработка ошибок в программе (пример с собаками) class Dog: def init(self, name, age): try: self.name = name self.age = int(age) except ValueError: print("Ошибка: возраст должен быть числом.") self.age = None

def main(): try: dogs = [] with open('dogs.txt', 'r') as f: for line in f: name, age = line.strip().split(',') dogs.append(Dog(name, age)) except Exception as e: print(f'Ошибка: {e}')

main() 8. Удаление слов-паразитов def remove_fillers(input_file, output_file): try: with open(input_file, 'r') as f: text = f.read()

filtered_text = ' '.join(word for word in text.split() if word != 'короче')

with open(output_file, 'w') as f:
    f.write(filtered_text)
except Exception as e: print(f'Ошибка: {e}') remove_fillers('input.txt', 'filtered_output.txt') 9. Подсчет количества слов в тексте def count_words(input_file, output_file): try: with open(input_file, 'r') as f: text = f.read()

word_count = len(text.split())

with open(output_file, 'w') as f:
    f.write(f'Количество слов: {word_count}\n')
except Exception as e: print(f'Ошибка: {e}') count_words('input.txt', 'word_count_output.txt') 10. Строки с словами, начинающимися на «А» def lines_with_a(input_file, output_file): try: with open(input_file, 'r') as f: lines = f.readlines()

filtered_lines = [line for line in lines if any(word.startswith('А') for word in line.split())]

with open(output_file, 'w') as f:
    f.writelines(filtered_lines)
except Exception as e: print(f'Ошибка: {e}') lines_with_a('input.txt', 'lines_with_a_output.txt') Эти программы обрабатывают различные задачи по работе с файлами и данными, как вы и запросили. Не забудьте заменить имена файлов на актуальные для вашего проекта.

Слова, начинающиеся с буквы «А» def words_starting_with_a(input_file, output_file): try: with open(input_file, 'r') as f: text = f.read()

words = [word for word in text.split() if word.startswith('А') or word.startswith('а')]

with open(output_file, 'w') as f: for word in words: f.write(f'{word}\n') except Exception as e: print(f'Ошибка: {e}')

words_starting_with_a('input.txt', 'words_with_a_output.txt') 12. Замена слова «паровоз» на «пароход» def replace_word(input_file, output_file, old_word, new_word): try: with open(input_file, 'r') as f: text = f.read()

modified_text = text.replace(old_word, new_word)

with open(output_file, 'w') as f:
    f.write(modified_text)
except Exception as e: print(f'Ошибка: {e}') replace_word('input.txt', 'modified_output.txt', 'паровоз', 'пароход') 13. Фамилии и имена учеников с баллами больше 80 def students_above_80(input_file, output_file): try: with open(input_file, 'r') as f: lines = f.readlines()

students = [line.strip() for line in lines if line.strip() and int(line.split()[-1]) > 80]

with open(output_file, 'w') as f:
    for student in students:
        f.write(f'{student}\n')
except Exception as e: print(f'Ошибка: {e}') students_above_80('exam_results.txt', 'students_above_80.txt') 14. Нумерация студентов с баллами больше 80 def numbered_students_above_80(input_file, output_file): try: with open(input_file, 'r') as f: lines = f.readlines()

students = [line.strip() for line in lines if line.strip() and int(line.split()[-1]) > 80]

with open(output_file, 'w') as f:
    for index, student in enumerate(students, start=1):
        f.write(f'{index}) {student}\n')
except Exception as e: print(f'Ошибка: {e}') numbered_students_above_80('exam_results.txt', 'numbered_students_above_80.txt') 15. Сокращение имени до одной буквы def abbreviated_students_above_80(input_file, output_file): try: with open(input_file, 'r') as f: lines = f.readlines()

students = [line.strip() for line in lines if line.strip() and int(line.split()[-1]) > 80]

abbreviated = [f'{student.split()[1][0]}. {student.split()[0]}' for student in students]

with open(output_file, 'w') as f:
    for index, student in enumerate(abbreviated, start=1):
        f.write(f'{index}) {student}\n')
except Exception as e: print(f'Ошибка: {e}') abbreviated_students_above_80('exam_results.txt', 'abbreviated_students_above_80.txt') 16. Сортировка по алфавиту (по фамилии) def alphabetically_sorted_students(input_file, output_file): try: with open(input_file, 'r') as f: lines = f.readlines()

students = [line.strip() for line in lines if line.strip() and int(line.split()[-1]) > 80]

abbreviated = [f'{student.split()[1][0]}. {student.split()[0]}' for student in students]
sorted_students = sorted(abbreviated, key=lambda x: x.split()[1])  # Сортировка по фамилии

with open(output_file, 'w') as f:
    for index, student in enumerate(sorted_students, start=1):
        f.write(f'{index}) {student}\n')
except Exception as e: print(f'Ошибка: {e}') alphabetically_sorted_students('exam_results.txt', 'sorted_students_above_80.txt') 17. Сортировка по убыванию полученного балла def sorted_by_score_descending(input_file, output_file): try: with open(input_file, 'r') as f: lines = f.readlines()

students = [line.strip().split() for line in lines if line.strip()]
students_with_scores = [(student[0], student[1], int(student[2])) for student in students]

# Фильтруем студентов с баллами больше 80
filtered_students = [student for student in students_with_scores if student[2] > 80]

# Сортировка по убыванию баллов
sorted_students = sorted(filtered_students, key=lambda x: x[2], reverse=True)

with open(output_file, 'w') as f:
    for index, (surname, name, score) in enumerate(sorted_students, start=1):
        f.write(f'{index}) {surname} {name} {score}\n')
except Exception as e: print(f'Ошибка: {e}') sorted_by_score_descending('exam_results.txt', 'sorted_students_by_score.txt') Эти программы выполняют ваши задачи, обрабатывая текстовые файлы и выводя результаты в соответствии с вашими требованиями. Не забудьте заменить имена файлов на актуальные для вашего проекта.

### Урок 69

Как вы понимаете высказывание К. Ф. Гаусса? К. Ф. Гаусс, известный математик, сделал много вкладов в различные области математики и науки. Одним из его известных высказываний является: "Всякая ошибка, если она не будет исправлена, становится правдой". Это подчеркивает важность точности и внимательности в измерениях и вычислениях, а также необходимость проверки и коррекции ошибок.

Какие величины можно измерять? Какие приборы для этого используются? Приведите примеры. Величины, которые можно измерять, включают:

Длину (например, линейка, рулетка) Массу (например, весы) Температуру (например, термометр) Давление (например, манометр) Электрический ток (например, амперметр) Напряжение (например, вольтметр) Какова цена деления у ваших наручных часов? Цена деления у наручных часов обычно составляет 1 секунду, что означает, что стрелка секундомера перемещается на одно деление каждую секунду.

Как определить цену деления для приборов с цифровыми индикаторами? Приведите примеры. Цена деления для цифровых приборов определяется как разница между двумя соседними значениями на дисплее. Например, если цифровой термометр показывает 20,0 °C и 20,1 °C, то цена деления составляет 0,1 °C. Если вольтметр показывает 1,20 В и 1,21 В, то цена деления составляет 0,01 В.

Что такое абсолютная и относительная погрешности? Какое из этих значений более важно в практических задачах?

Абсолютная погрешность — это разница между измеренным значением и истинным значением, выраженная в тех же единицах измерения. Например, если истинное значение 5 см, а измеренное 4,8 см, то абсолютная погрешность составляет 0,2 см. Относительная погрешность — это отношение абсолютной погрешности к истинному значению, часто выраженное в процентах. В приведенном примере относительная погрешность будет (0,2 см / 5 см) * 100% = 4%. В практических задачах более важно учитывать относительную погрешность, так как она показывает, насколько значима ошибка относительно размера измеряемой величины. Что такое вычислительно неустойчивый метод? Вычислительно неустойчивый метод — это метод, при использовании которого небольшие ошибки в исходных данных могут привести к значительным ошибкам в результатах. Это может происходить, например, при вычислении корней полиномов или при решении систем линейных уравнений, если матрица плохо обусловлена.

Перечислите источники погрешностей при компьютерных вычислениях.

Ошибки округления Ошибки измерения Неустойчивые алгоритмы Ограниченная точность представления чисел (например, использование чисел с плавающей запятой) Человеческий фактор (ошибки ввода данных) Какие задачи изучает вычислительная математика? Вычислительная математика изучает задачи, связанные с численным решением математических проблем, включая:

Численное интегрирование и дифференцирование Решение систем линейных и нелинейных уравнений Оптимизация Моделирование физических процессов Анализ устойчивости численных методов Сообщения а) «Абсолютная и относительная погрешность» Абсолютная погрешность — это разница между измеренным значением и истинным значением. Она выражается в тех же единицах измерения, что и само значение. Относительная погрешность — это отношение абсолютной погрешности к истинному значению, выраженное в процентах. Относительная погрешность позволяет оценить значимость ошибки относительно размера измеряемой величины и часто важнее абсолютной, так как показывает, насколько ошибка влияет на результат.

б) «Вычислительная устойчивость методов» Вычислительная устойчивость методов — это свойство численных алгоритмов, при котором небольшие изменения в входных данных приводят к небольшим изменениям в выходных данных. Устойчивые методы позволяют получать надежные результаты, даже если данные имеют определенные погрешности. Примеры устойчивых методов включают методы интерполяции, численного интегрирования и решения линейных уравнений.

Задачи Как изменятся абсолютная и относительная погрешности результата, если при вычислении площади сечения использовать число 3,147? Если вместо числа π (приблизительно 3,14159) использовать число 3,147, то абсолютная погрешность будет равна разнице между истинным значением площади и рассчитанным значением. Относительная погрешность будет определяться как отношение абсолютной погрешности к истинному значению площади. Это зависит от конкретного случая и размеров сечения.

Радиус шарика R измерили с точностью 0,1 см и получили 1,2 см. Затем рассчитали его объём по формуле V 4 3 π R 3 V= 3 4

πR 3 . Запишите ответ в этой задаче, оставив нужное количество значащих цифр. Сначала вычислим объём:

V 4 3 π ( 1 , 2 ) 3 ≈ 4 3 ⋅ 3 , 14159 ⋅ 1 , 728 ≈ 7 , 23822947387088 см 3 V= 3 4

π(1,2) 3 ≈ 3 4

⋅3,14159⋅1,728≈7,23822947387088 см 3

С учётом точности измерения радиуса (0,1 см) и округления, ответ можно записать как:

V ≈ 7 , 24 см 3 V≈7,24 см 3

С помощью рулетки размеры бруса (220 см х 11 см х 10 см) измерили с точностью 1 см. Определите его объём. Запишите ответ с учётом точности полученного результата. Объём бруса рассчитывается по формуле:

V 220 см × 11 см × 10 см 24200 см 3 V=220 см×11 см×10 см=24200 см 3

С учётом погрешности измерений (1 см), объём можно записать как:

V 24200 ± 220 см 3 V=24200±220 см 3

Пётр и Павел измеряют плотность меди. У них есть медные бруски разной величины, линейка и весы. Пётр взял брусок с размерами (по результатам измерений) 2 х 2 х 2 см, а Павел - с размерами 5 х 5 х 5 см. При измерении массы брусков у Петра получилось 70 г, а у Павла 1120 г. Погрешность измерения длины — 1 мм, погрешность измерения массы 10 г. С какой абсолютной и относительной погрешностью определили плотность меди Пётр и Павел? Какой брусок нужно было выбирать, чтобы погрешность была наименьшей?

Пётр:

Объём: V 2 × 2 × 2 8 см 3 V=2×2×2=8 см 3

Масса: m 70 г m=70 г Плотность: ρ m V 70 8 8 , 75 г/см 3 ρ= V m

= 8 70

=8,75 г/см 3

Погрешности:

Абсолютная погрешность объёма: Δ V 3 × 1 см 3 см 3 ΔV=3×1 см=3 см 3

Абсолютная погрешность массы: Δ m 10 г Δm=10 г Плотность с погрешностью:

Δ ρ ρ × ( Δ m m ) 2 + ( Δ V V ) 2 Δρ=ρ× ( m Δm

) 2 +( V ΔV

) 2

Δ ρ 8 , 75 × ( 10 70 ) 2 + ( 3 8 ) 2 ≈ 8 , 75 × 0 , 0204 + 0 , 1406 ≈ 8 , 75 × 0 , 387 ≈ 3 , 39 г/см 3 Δρ=8,75× ( 70 10

) 2 +( 8 3

) 2

≈8,75× 0,0204+0,1406

≈8,75×0,387≈3,39 г/см 3

Павел:

Объём: V 5 × 5 × 5 125 см 3 V=5×5×5=125 см 3

Масса: m 1120 г m=1120 г Плотность: ρ m V 1120 125 8 , 96 г/см 3 ρ= V m

= 125 1120

=8,96 г/см 3

Погрешности:

Абсолютная погрешность объёма: Δ V 3 × 1 см 3 см 3 ΔV=3×1 см=3 см 3

Абсолютная погрешность массы: Δ m 10 г Δm=10 г Плотность с погрешностью:

Δ ρ 8 , 96 × ( 10 1120 ) 2 + ( 3 125 ) 2 ≈ 8 , 96 × 0 , 00079 + 0 , 0576 ≈ 8 , 96 × 0 , 240 ≈ 2 , 15 г/см 3 Δρ=8,96× ( 1120 10

) 2 +( 125 3

) 2

≈8,96× 0,00079+0,0576

≈8,96×0,240≈2,15 г/см 3

Вывод: Плотность Петра: 8 , 75 ± 3 , 39 г/см 3 8,75±3,39 г/см 3

Плотность Павла: 8 , 96 ± 2 , 15 г/см 3 8,96±2,15 г/см 3

Таким образом, брусок Павла имеет меньшую относительную погрешность, и его результаты более точны.
